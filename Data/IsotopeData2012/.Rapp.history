rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5, 6.5, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5, 6.5, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 150 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 150000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
min(diff(Xobs[,3]))
which.min(diff(Xobs[,3]))
Kgrad[562646]
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.01, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.4, 2.56, 1.7) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.4, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.4, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.4, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.5, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 50000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
which.min(diff(Xobs[,3]))
Xobs[154006,]
Xobs[154000: 154010,]
Xobs[154006,3]
diff(Xobs[,3])[154006]
diff(Xobs[,3])[154005]
Xobs[153900: 154010,]
Xobs[153900: 154050,]
Xobs[153900: 154100,]
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.25, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.25, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 10000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6.25, 6.75, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
kQuse <- 0.565#
hQuse <- 0.5#
#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
DaysPerK <- 1#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
#
xNaught <- c(0.5, 2.56, 1.9) #Starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2)#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
?par
#The graphs plot as a series of rows
?par
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of nutrient loading (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.5, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
print("hi")
library("rootSolve")
?rootSolve
var(2*rnorm(n=1000))
var(1*rnorm(n=1000))
var(2*rnorm(n=1000))
var(2*rnorm(n=10000))
var(1*rnorm(n=10000))
sd(1*rnorm(n=10000))
sd(2*rnorm(n=10000))
sd(1*rnorm(n=10000, sd=1))
sd(1*rnorm(n=10000, sd=2))
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.5, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 200 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.5, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 200 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.1, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 200 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 3 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 4 #For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 20 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 2 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,1) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- #
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,0.1) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.01,3.4,0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.7,4,0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.8, 4.4, 0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.8, 4.5, 0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.8, 4.5, 0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <- c(0.8, 4.5, 0.25) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.01, 2.5, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 100 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 200 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 250 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
TRUE*2
FALSE*2
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaUse <- 0.1#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,]#
}#
#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,]#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
as.numeric(TRUE)
as.numeric(FALSE)
as.numeric(c(FALSE, TRUE, FALSE, FALSE))
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.1#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.001#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.0001#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.0005#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
Sigma <- 0.001#
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.005, 0.05, 0.01) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
Noise2 <- matrix(data=rnorm(n=(Nobs*3), mean=0, sd=Sigma), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.005, 0.05, 0.01) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0005, 0.005, 0.001) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
SigmaPQZ[3]
Noise1
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0005, 0.005, 0.001) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.005, 0.05, 0.01) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.005, 0.05, 0.005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.001, 0.01, 0.005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0008, 0.008, 0.005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0008, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.008, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.009, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0009, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.01, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.01, 0.0008, 0.005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.01, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.001, 0.0008, 0.0005) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.001, 0.256, 0.19) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.0256, 0.019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(6, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
?rlnrom
?rnorm
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.0256, 0.019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3)#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=Kgrad[i], kQ=kQuse)*dt + Xobs[i-1,] + Noise1[i,]*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=Kgrad[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
#
# ===============#
# = Make Graphs =#
# ===============#
# dev.new(width=8, height=10)#
# par(mfcol=c(4,2), cex=1.25, mar=c(1,2,1,0.2), oma=c(3, 1, 1, 1))#
# #
# 	# =========================================#
# 	# = Plot state variables for increasing K =#
# 	# =========================================#
# plot(Time, Kgrad, type="l", xaxt="n", xlab="", ylab="", lwd=2)#
# mtext("K", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim)#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# mtext("Unicell", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim)#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# mtext("Colonial", side=2, line=2, cex=1.25)#
# axis(side=1, labels=FALSE)#
# #
# plot(Time, Xobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim)#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
# #
# #
# #
# 	# =========================================#
# 	# = Plot state variables for decreasing K =#
# 	# =========================================#
# plot(Time, rev(Kgrad), type="l", xaxt="n", xlab="", ylab="", lwd=2, yaxt="n")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"P"], type="l", col="green2", xaxt="n", xlab="", ylab="", lwd=2, ylim=pYlim, yaxt="n")#
# # axis(side=3, at=pretty(1:length(Kgrad)), labels=pretty(Kgrad))#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Q"], type="l", col="cyan3", xaxt="n", xlab="", ylab="", lwd=2, ylim=qYlim, yaxt="n")#
# abline(v=c(1.67, 5.81, 8.21), lty="dotted")#
# axis(side=1, labels=FALSE); axis(side=2, labels=FALSE)#
# #
# plot(Time, revXobs[,"Z"], type="l", col="magenta2", xlab="Time", ylab="", lwd=2, ylim=zYlim, yaxt="n")#
# axis(side=2, labels=FALSE)#
# #
# mtext("Time (days)", side=1, line=1, cex=1.25, outer=TRUE)#
#
	#
# ====================================================#
# = Plot forwards and backwards on top of each other =#
# ====================================================#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- cbind(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(as.data.frame(ReturnStats1))#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)
install.packages("ggplot2")
head(Stats_Xobs); tail(Stats_Xobs)
library("ggplot2")
?aes
?aes_facet
?ggplot_facet
?ggplot_facets
?aes_facet
?aes_facets
?geom_tile
head(Stats_Xobs); tail(Stats_Xobs)
ggplot(Stats_Xobs) + aes(P+Q+Z ~Stat)
?aes
ggplot(Stats_Xobs) + aes(P ~Stat)
ggplot(Stats_Xobs)
ggplot(Stats_Xobs, aes(X=Time, y=P))
Stats_Xobs
head(Stats_Xobs); tail(Stats_Xobs)
qplot(Time, P, data=Stats_Xobs, group=Stat, geom="line")
install.packages("ggplot2",#
type = "source")
library("ggplot2")
qplot(Time, P, data=Stats_Xobs, group=Stat, geom="line")
ggplot(Time, P, data=Stats_Xobs, group=Stat, geom="line")
?aes
?aes_string
# mtext("Unicell", side=2, line=2, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 20 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- cbind(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(as.data.frame(ReturnStats1))#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)
ggplot(Stats_Xobs)
ggplot(Stats_Xobs) +aes(x=Time, y=P, group=Stat) +geom_line()
ggplot(Stats_Xobs, aes(x=Time, y=P, group=Stat)) +geom_line()
ggplot(Stats_Xobs[1:1000,], aes(x=Time, y=P, group=Stat)) +geom_line()
ggplot(Stats_Xobs[1:100,], aes(x=Time, y=P, group=Stat)) +geom_line()
dev.new(width=6, height=9)
dev.new(width=8, height=8)
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs)#
dev.new(width=8, height=8)#
par(mfcol=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}
unique(Stats_Xobs)
Statters <- unique(Stats_Xobs[,"Stat"])
Statters
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfcol=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- cbind(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(as.data.frame(ReturnStats1))#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfcol=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}#
#
#
# dev.new(height=7, width=5)#
# par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
# plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
# lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
# axis(side=1, labels=FALSE)#
# mtext("Unicell", side=2, line=2, cex=1.25)#
#
# plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
# lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
# axis(side=1, labels=FALSE)#
# mtext("Colonial", side=2, line=2, cex=1.25)#
#
# plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
# lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
# mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
# mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.000001, 0.0000256, 0.000019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- cbind(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(as.data.frame(ReturnStats1))#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfcol=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.000001, 0.0000256, 0.000019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- cbind(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(as.data.frame(ReturnStats1))#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfcol=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
dev.new(width=8, height=8)#
par(mfrow=c(length(Statters), length(PQZ)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
			plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		#
	}#
	#
}
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}
head(Stats_Xobs); tail(Stats_Xobs)
PQZ[i]
j_Xobs[,PQZ[i]]
dim(j_Xobs)
data.frame("test"=rep(0,4996), j_Xobs)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.000001, 0.0000256, 0.000019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=200#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
dim(Xobs)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.000001, 0.0000256, 0.000019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.00001, 0.000256, 0.00019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 5000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 5 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.00001, 0.000256, 0.00019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 2000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 5 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.00001, 0.000256, 0.00019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 20000 #Number of days over which to simulate#
DailySteps <- 5 #Number of steps per day (this is essentially dt)#
DaysPerK <- 50 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.00001, 0.000256, 0.00019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)
save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 100 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
?axis
axis(side=1, labels=Kgrad)
axis(side=1, labels=Kgrad, at=Kgrad)
axis(side=1, labels=TRUE, at=Kgrad)
axis(side=3, labels=TRUE, at=Kgrad)
axis(side=3, labels=TRUE, at=Kgrad, line=0)
		plot(Kgrad, j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#j_Xobs[,"Time"]
length(Kgrad)
length(j_Xobs[,"Time"])
		plot(Kgrad[-1:4], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#j_Xobs[,"Time"]
		plot(Kgrad[-c(1:4)], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#j_Xobs[,"Time"]
Kgrad[-c(1:4)]
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(Kgrad[-c(1:4)], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#j_Xobs[,"Time"]#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
axis(side=3, labels=TRUE, at=Kgrad, line=0)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
axis(side=1, labels=TRUE, at=Kgrad, line=0)
axis(side=1, labels=TRUE, at=pretty(Kgrad), line=0)
axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(3,3,1,0.1), oma=c(1.5, 1.5, 1, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		plot(Kgrad[-c(1:4)], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="")#j_Xobs[,"Time"]#
		if(i==1){mtext(Statters[j], side=3, line=1, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		#
	}#
	#
}#
axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		if(i==1){axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
dev.new(); plot(1:10, 1:10)
axis(side=3)
		if(i==1){axis(side=1, labels=TRUE, at=pretty(Kgrad)}
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		if(i==1){axis(side=1, labels=TRUE, at=pretty(Kgrad))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		if(i==1){axis(side=3, labels=TRUE, at=pretty(Kgrad))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
pretty(Kgrad)
axis(side=3, labels=TRUE, at=pretty(seq_along(Kgrad)))
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		if(i==1){axis(side=3, labels=TRUE, at=pretty(seq_along(Kgrad)))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
pretty(seq_along(Kgrad))
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		if(i==1){axis(side=3, labels=pretty(seq_along(Kgrad)), at=pretty(seq_along(Kgrad)))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
pretty(seq_along(Kgrad))
pretty(seq_along(j_Xobs[,"Time"]))
pretty(j_Xobs[,"Time"])
		if(i==1){axis(side=3, labels=pretty(seq_along(Kgrad)), at=pretty(j_Xobs[,"Time"]))}
axis(side=3, labels=pretty(seq_along(Kgrad)), at=pretty(j_Xobs[,"Time"]))
length(Kgrad)
length(j_Xobs[,"Time"])
		seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))
		Kaxis <- Kgrad[-seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))]
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		Kaxis <- Kgrad[-seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))] #account for the difference in the lenths of Time and the Kgradient, due to calculating stats and size of window#
		if(i==1){axis(side=3, labels=pretty(Kaxis), at=pretty(j_Xobs[,"Time"]))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
pretty(Kaxis)
pretty(j_Xobs[,"Time"])
?pretty
pretty(Kaxis, n=5)
pretty(Kaxis, n=4)
pretty(j_Xobs[,"Time"], n=4)
pretty(j_Xobs[,"Time"], n=2)
pretty(Kgrad)
axTicks(Kaxis)
which(is.element(Kgrad, pretty(Kgrad))
)
Kgrad
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 500 #Number of days over which to simulate#
DailySteps <- 10 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		Kaxis <- Kgrad[-seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))] #account for the difference in the lenths of Time and the Kgradient, due to calculating stats and size of window#
		# if(i==1){axis(side=3, labels=pretty(Kaxis), at=pretty(j_Xobs[,"Time"]))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 24 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2, 1.4) #c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		Kaxis <- Kgrad[-seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))] #account for the difference in the lenths of Time and the Kgradient, due to calculating stats and size of window#
		# if(i==1){axis(side=3, labels=pretty(Kaxis), at=pretty(j_Xobs[,"Time"]))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
rm(list=ls())#
graphics.off()#
library("zoo")#
library("ggplot2")#
#
# ====================#
# = Set some options =#
# ====================#
kQuse <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
hQuse <- 0.5 #Handling time on colonial algae at kQ = 0, day#
Days <- 1000 #Number of days over which to simulate#
DailySteps <- 24 #Number of steps per day (this is essentially dt)#
DaysPerK <- 1 #"Days" has to be a multiple of DaysPerK. For each rate of carrying capacity (nutrient loading) (k), how many days should that rate be maintained (e.g., if 7, k will only change once per week)#
xNaught <- c(0.01, 2.25, 1.4) #c(0.01, 2.56, 1.9) #When k is increasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
revxNaught <-  c(0.8, 4.5, 0.25) #c(0.01, 3.4, 2) #When k is decreasing over the simulation, these are the starting values for unicell, colonial, and zoops (g/m^3)#
SigmaPQZ <- c(0.0001, 0.00256, 0.0019)*1.25  #c(0.000001, 0.000256, 0.00019) #
AddNoise <- c(TRUE, FALSE)[1] #Will be used as a coefficient in the noise simulations.  In multiplication, R interprets TRUE as 1, and FALSE as 0.#
AddKnoise <- c(TRUE, FALSE)[2]#
Ksd <- 0.25#
AddCata <- c(TRUE, FALSE)[2]#
CataAmp <- 100#
ProbCata <- 0.005#
#
WinSize=50#
#
#
# ================================================#
# = Main function to calculate dXdt at each step =#
# ================================================#
xRates <- function(x0, K, hQ=0.5, kQ=0.565){#
	# ==============#
	# = Parameters =#
	# ==============#
	# K <- 5.0 #Carrying capacity, g/m^3#
	r <- 1.0 #Maximum growth rate of algae, day^-1#
	c <- 1.0 #scaling parameter for inducible effect, day^-1#
	g <- 0.1 #half-saturation constant for inducible effect, g/m^3#
	vP <- 0.5 #search rate on unicellular algae, m^2 g^-1 day^-1#
	hP <- 0.5 #handling time on unicellular algae, day#
	mP <- 0.2 #Mortality rate of unicellular algae, day^-1#
	vQ <- 0.5 #Search rate on colonial algae, m^3 g^-1 day^-1#
	# hQ <- 0.5 #Handling time on colonial algae at kQ = 0, day#
	# kQ <- 0.565 #Increasing rate of handling time on colonial algae, m^3 g^-1#
	mQ <- 0.2 #Mortality rate of colonial algae, day^-1#
	nu <- 0.4 #assimilation coefficient on algae#
	mZ <- 0.2 #Mortality rate of zooplankton, day^-1 #Changing mortality to 0.15 under the conditions of Fig. 5 in Serizawa 2007 produces weird oscillations at K>4.71#
	#
	# =========================#
	# = State variable values =#
	# =========================#
	P <- x0[1]#
	Q <- x0[2]#
	Z <- x0[3]#
	#
	# =========#
	# = Rates =#
	# =========#
	#First define convenient, repeatable parts to the equations#
	Logis <- r*(1 - (P+Q)/K)#
	PInduc <- P*(c*Z^2)/(Z^2+g^2)#
	QInduc <- Q*(c*g^2)/(Z^2+g^2)#
	ConsP <- vP*hP*P#
	ConsQ <- vQ*hQ*Q*(1+kQ*Q)#
	#
	#Simulate each dimension#
	dPdt <- P*Logis - PInduc + QInduc - (vP*P*Z)/(1 + ConsP + ConsQ) - mP*P#
	dQdt <- Q*Logis + PInduc - QInduc - (vQ*Q*Z)/(1 + ConsP + ConsQ) - mQ*Q#
	dZdt <- (nu*(vP*P + vQ*Q)*Z)/(1 + ConsP + ConsQ) - mZ*Z#
	#
	#Save dXdt's as a vector for P, Q, and Z#
	dXdt <- c(dPdt, dQdt, dZdt)#
	#
	return(dXdt)#
}#
#
Ar1 <-function(x){#
	ac <- cor(x[-1],x[-length(x)])#
	# Nrmlzd <- x-mean(x)#
	# Y <- (x-mean(x))[-1]#
	# return(lm(Nrmlzd[-1] ~ Nrmlzd[-length(x)])$coef[[2]])#
	#return(arima(x, order=c(1,0,0))$coef[[1]])#
	return(ac)#
}#
#
CH <- function(X){#
	nobs <- length(X)#
	Xt0 <- X[-c(1:4)]#
	Xt1 <- X[-c(1:3, nobs)]#
	Xt2 <- X[-c(1:2, (nobs-1):nobs)]#
	Xt3 <- X[-c(1, (nobs-2):nobs)]#
	Xt4 <- X[-c((nobs-3):nobs)]#
	ModelAR <- lm(Xt0~Xt1+Xt2+Xt3+Xt3+Xt4)#
	Res <- as.numeric(ModelAR$resid)#
	Res2 <- Res^2#
	Res2t0 <- Res2[-1]#
	Res2t1 <- Res2[-length(Res2)]#
	ModelCH <- lm(Res2t0~Res2t1)#
	R2 <- summary(ModelCH)$r.squared#
	# PosResult <- ifelse(Pvalue<=0.05,1,0)#
	return(R2)#
}#
#
SquealStats <- function(Data, WinSize){#
	StatNames <- c("Var", "AR1")#
	ReturnStats0 <- rbind(apply(Data, 2, rollapplyr, width=WinSize, var), apply(Data, 2, rollapplyr, width=WinSize, Ar1))#
	colnames(ReturnStats0) <- colnames(Data)#
	nstatsPer <- nrow(ReturnStats0)/length(StatNames)#
	ReturnStats1 <- data.frame(ReturnStats0, "Stat"=c(rep(StatNames[1],nstatsPer), rep(StatNames[2], nstatsPer)))#
	return(ReturnStats1)#
}#
# test <- SquealStats(Xobs, 5)#
# head(test)#
# tail(test)#
#
# SquealStats <- function(Data, WinSize){	#
	# ReturnStats <- data.frame("Var"=rollapplyr(Data, width=WinSize, FUN=var), "AR1"=rollapplyr(Data, width=WinSize, FUN=Ar1))#
	# return(ReturnStats)#
# }#
# , "CH"=rollapplyr(Data, width=WinSize, FUN=CH)#
# ===========================================================================================================#
# = Set up the simulation (given the options chosen at top of script, define duration, frequency, dt, etc.) =#
# ===========================================================================================================#
Nobs <- Days*DailySteps #number of observations to be simulated#
Time <- seq(1,Days+(1-1/DailySteps), by=1/DailySteps)#
dt <- 1/DailySteps #the size of the time step in units=days#
Kgrad <- rep(seq(5.5, 7, length.out=Days/DaysPerK), each=DailySteps*DaysPerK) #changes in carrying capacity for each Euler iteration, but K only changes between days, not within a day#
Xobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
Xobs[1,] <- xNaught#
revXobs <- matrix(data=NA, nrow=Nobs, ncol=3, dimnames=list(NULL,c("P","Q","Z"))) #To store the simulated state variables#
revXobs[1,] <- revxNaught #Xobs[Nobs,] #Xobs[Nobs,]#*2#
#
# Noise <- matrix(rnorm(n=Nobs*3, mean=0, sd=0.001), nrow=Nobs, ncol=3)#
# AddNoise <- c(TRUE, FALSE)[2]#
#
# =====================================#
# = Simulate time series of P, Q, & Z =#
# =====================================#
Noise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
Noise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]), rnorm(n=Nobs, sd=SigmaPQZ[2]), rnorm(n=Nobs, sd=SigmaPQZ[3])), ncol=3) * AddNoise#
#
KgradSim <- Kgrad + (rnorm(n=Nobs, sd=Ksd)*AddKnoise)#
# Knoise2 <- rnorm(n=Nobs, sd=Ksd)*AddKnoise#
#
CataNoise1 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
CataNoise2 <- matrix(data=c(rnorm(n=Nobs, sd=SigmaPQZ[1]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[2]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata), rnorm(n=Nobs, sd=SigmaPQZ[3]*CataAmp)*rbinom(n=Nobs, size=1, prob=ProbCata)), ncol=3) * AddCata#
#
#Simulate while increasing k#
for(i in 2:Nobs){#
	Xobs[i,] <- xRates(x0=Xobs[i-1,], K=KgradSim[i], kQ=kQuse)*dt + Xobs[i-1,] + (Noise1[i,] + CataNoise1[i,])*sqrt(dt)#
}#
#Simulate while decreasing k#
for(i in 2:Nobs){#
	revXobs[i,] <- xRates(x0=revXobs[i-1,], K=KgradSim[Nobs-i], kQ=kQuse)*dt + revXobs[i-1,] + Noise2[i,]*sqrt(dt)#
}#
#
#
pYlim <- range(c(range(Xobs[,"P"]), range(revXobs[,"P"])))#
qYlim <- range(c(range(Xobs[,"Q"]), range(revXobs[,"Q"])))#
zYlim <- range(c(range(Xobs[,"Z"]), range(revXobs[,"Z"])))#
# qui <- function(x) ma#
Stats_Xobs <- data.frame("Time"=rollapplyr(Time, width=5, max), SquealStats(Xobs, WinSize=5))#
head(Stats_Xobs); tail(Stats_Xobs)#
#next use ggplot and ddply to make a multi-panel graph in one step.  this is going to be sick when it works.#
PQZ <- c("P", "Q", "Z")#
Statters <- unique(Stats_Xobs[,"Stat"])#
dev.new(width=8, height=8)#
par(mfrow=c(length(PQZ), length(Statters)), mar=c(2,3,1,0.1), oma=c(1.5, 1.5, 3, 0), cex=1)#
for(i in seq_along(PQZ)){#
	i_Xobs <- Stats_Xobs[,c("Time",PQZ[i],"Stat")]#
	for(j in seq_along(Statters)){#
		j_Xobs <- i_Xobs[which(i_Xobs[,"Stat"]==Statters[j]),]#
		if(i==3){Xaxt <- "s"}else{Xaxt <- "n"}#
		plot(j_Xobs[,"Time"], j_Xobs[,PQZ[i]], type="l", xlab="", ylab="", xaxt=Xaxt)#j_Xobs[,"Time"]#
		if(i!=3){axis(side=1, labels=FALSE)}#
		if(i==1){mtext(Statters[j], side=3, line=3, font=2)}#
		if(j==1){mtext(PQZ[i], side=2, line=3, font=2)}#
		Kaxis <- Kgrad[-seq_len(length(Kgrad)-length(j_Xobs[,"Time"]))] #account for the difference in the lenths of Time and the Kgradient, due to calculating stats and size of window#
		# if(i==1){axis(side=3, labels=pretty(Kaxis), at=pretty(j_Xobs[,"Time"]))}#
		#
	}#
	#
}#
# axis(side=1, labels=TRUE, at=pretty(Kgrad), line=3)#
#
#
dev.new(height=7, width=5)#
par(mfrow=c(3,1), mar=c(1,3,1,1), cex=1.25, oma=c(3,0,0,0))#
#
plot(Kgrad, Xobs[,"P"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="green4", ylim=pYlim)#
lines(rev(Kgrad), revXobs[,"P"], lwd=2, col="green")#
axis(side=1, labels=FALSE)#
mtext("Unicell", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Q"], type="l", xaxt="n", xlab="", ylab="", lwd=2, col="cyan4", ylim=qYlim)#
lines(rev(Kgrad), revXobs[,"Q"], lwd=2, col="cyan")#
axis(side=1, labels=FALSE)#
mtext("Colonial", side=2, line=2, cex=1.25)#
#
plot(Kgrad, Xobs[,"Z"], type="l", xlab="", ylab="", lwd=2, col="magenta4", ylim=zYlim)#
lines(rev(Kgrad), revXobs[,"Z"], lwd=2, col="magenta")#
mtext("Zooplankton", side=2, line=2, cex=1.25)#
#
mtext("K \n Dark = Increasing, Light = Decreasing", side=1, line=3, cex=1.25)#
#
#
# save.image("/Users/Battrd/Documents/School&Work/WiscResearch/BloomModel/Batt_Bloom_Seri07_v0_22Sept2012.RData")
setwd("/Users/Battrd/Documents/School&Work/WiscResearch/Data/IsotopeData2012")#
Meta <- read.csv("IsotopeMetaData.csv")#
Data0 <- read.csv("IsotopeNewData2012_dD.csv")
dim(Meta)
dim(Data0)
Data <- merge (Data0, Meta, by=SampleID, all.x=TRUE)
Data <- merge (Data0, Meta, by="SampleID", all.x=TRUE)
Data
?write.csv
write.csv(Data, file="IsotopeData_dD&Meta_2012.csv")
rm(list=ls())#
graphics.off()#
#
setwd("/Users/Battrd/Documents/School&Work/WiscResearch/Data/IsotopeData2012")#
Meta <- read.csv("IsotopeMetaData.csv")#
Data0 <- read.csv("IsotopeNewData2012_dD.csv")#
#
Data <- merge (Data0, Meta, by="SampleID", all.x=TRUE)#
#
write.csv(Data, file="IsotopeData_dD&Meta_2012.csv")
rm(list=ls())
graphics.off()
531-197
337-3
